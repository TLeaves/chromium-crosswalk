// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/themes/theme_service.h"

#include "base/feature_list.h"
#include "base/no_destructor.h"
#include "build/build_config.h"
#include "build/chromeos_buildflags.h"
#include "chrome/browser/themes/browser_theme_pack.h"
#include "chrome/browser/themes/custom_theme_supplier.h"
#include "chrome/browser/themes/theme_properties.h"
#include "chrome/browser/ui/color/chrome_color_provider_utils.h"
#include "chrome/browser/ui/ui_features.h"
#include "chrome/common/chrome_features.h"
#include "chrome/grit/theme_resources.h"
#include "components/grit/components_scaled_resources.h"
#include "components/omnibox/browser/omnibox_field_trial.h"
#include "ui/base/resource/resource_bundle.h"
#include "ui/gfx/color_palette.h"
#include "ui/gfx/color_utils.h"
#include "ui/gfx/image/image.h"
#include "ui/native_theme/common_theme.h"
#include "ui/native_theme/native_theme.h"

#if BUILDFLAG(IS_LINUX)
#include "ui/views/linux_ui/linux_ui.h"
#endif

namespace {

using TP = ThemeProperties;

// The default theme if we've gone to the theme gallery and installed the
// "Default" theme. We have to detect this case specifically. (By the time we
// realize we've installed the default theme, we already have an extension
// unpacked on the filesystem.)
constexpr char kDefaultThemeGalleryID[] = "hkacjpbfdknhflllbcmjibkdeoafencn";

SkColor IncreaseLightness(SkColor color, double percent) {
  color_utils::HSL result;
  color_utils::SkColorToHSL(color, &result);
  result.l += (1 - result.l) * percent;
  return color_utils::HSLToSkColor(result, SkColorGetA(color));
}

// Key for cache of separator colors; pair is <tab color, frame color>.
using SeparatorColorKey = std::pair<SkColor, SkColor>;
using SeparatorColorCache = std::map<SeparatorColorKey, SkColor>;

SeparatorColorCache& GetSeparatorColorCache() {
  static base::NoDestructor<SeparatorColorCache> cache;
  return *cache;
}

}  // namespace

const char ThemeHelper::kDefaultThemeID[] = "";

// static
bool ThemeHelper::IsExtensionTheme(const CustomThemeSupplier* theme_supplier) {
  return theme_supplier &&
         theme_supplier->get_theme_type() ==
             ui::ColorProviderManager::ThemeInitializerSupplier::ThemeType::
                 kExtension;
}

// static
bool ThemeHelper::IsAutogeneratedTheme(
    const CustomThemeSupplier* theme_supplier) {
  return theme_supplier &&
         theme_supplier->get_theme_type() ==
             ui::ColorProviderManager::ThemeInitializerSupplier::ThemeType::
                 kAutogenerated;
}

// static
bool ThemeHelper::IsDefaultTheme(const CustomThemeSupplier* theme_supplier) {
  if (!theme_supplier)
    return true;

  using Type = ui::ColorProviderManager::ThemeInitializerSupplier::ThemeType;

  switch (theme_supplier->get_theme_type()) {
    case Type::kIncreasedContrast:
      return true;
    case Type::kExtension: {
      const std::string& id = theme_supplier->extension_id();
      return id == kDefaultThemeID || id == kDefaultThemeGalleryID;
    }
    case Type::kNativeX11:
    case Type::kAutogenerated:
      return false;
  }
}

// static
bool ThemeHelper::IsCustomTheme(const CustomThemeSupplier* theme_supplier) {
  return IsExtensionTheme(theme_supplier) ||
         IsAutogeneratedTheme(theme_supplier);
}

// static
bool ThemeHelper::HasCustomImage(int id,
                                 const CustomThemeSupplier* theme_supplier) {
  return BrowserThemePack::IsPersistentImageID(id) && theme_supplier &&
         theme_supplier->HasCustomImage(id);
}

// static
int ThemeHelper::GetDisplayProperty(int id,
                                    const CustomThemeSupplier* theme_supplier) {
  int result = 0;
  if (theme_supplier && theme_supplier->GetDisplayProperty(id, &result)) {
    return result;
  }

  switch (id) {
    case TP::NTP_BACKGROUND_ALIGNMENT:
      return TP::ALIGN_CENTER;

    case TP::NTP_BACKGROUND_TILING:
      return TP::NO_REPEAT;

    case TP::NTP_LOGO_ALTERNATE:
      return 0;

    case TP::SHOULD_FILL_BACKGROUND_TAB_COLOR:
      return 1;

    default:
      return -1;
  }
}

// static
base::RefCountedMemory* ThemeHelper::GetRawData(
    int id,
    const CustomThemeSupplier* theme_supplier,
    ui::ResourceScaleFactor scale_factor) {
  // Check to see whether we should substitute some images.
  int ntp_alternate =
      GetDisplayProperty(TP::NTP_LOGO_ALTERNATE, theme_supplier);
  if (id == IDR_PRODUCT_LOGO && ntp_alternate != 0)
    id = IDR_PRODUCT_LOGO_WHITE;

  base::RefCountedMemory* data = nullptr;
  if (theme_supplier)
    data = theme_supplier->GetRawData(id, scale_factor);
  if (!data) {
    data =
        ui::ResourceBundle::GetSharedInstance().LoadDataResourceBytesForScale(
            id, ui::k100Percent);
  }

  return data;
}

ThemeHelper::ThemeHelper() = default;

ThemeHelper::~ThemeHelper() {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
}

SkColor ThemeHelper::GetColor(int id,
                              bool incognito,
                              const CustomThemeSupplier* theme_supplier) const {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);

  if (theme_supplier && !incognito) {
    SkColor color;
    if (theme_supplier->GetColor(id, &color))
      return color;
  }

  return GetDefaultColor(id, incognito, theme_supplier);
}

color_utils::HSL ThemeHelper::GetTint(
    int id,
    bool incognito,
    const CustomThemeSupplier* theme_supplier) const {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  color_utils::HSL hsl;
  if (theme_supplier && theme_supplier->GetTint(id, &hsl))
    return hsl;

  return TP::GetDefaultTint(id, incognito, UseDarkModeColors(theme_supplier));
}

gfx::ImageSkia* ThemeHelper::GetImageSkiaNamed(
    int id,
    bool incognito,
    const CustomThemeSupplier* theme_supplier) const {
  gfx::Image image = GetImageNamed(id, incognito, theme_supplier);
  if (image.IsEmpty())
    return nullptr;
  // TODO(pkotwicz): Remove this const cast.  The gfx::Image interface returns
  // its images const. GetImageSkiaNamed() also should but has many callsites.
  return const_cast<gfx::ImageSkia*>(image.ToImageSkia());
}

bool ThemeHelper::ShouldUseNativeFrame(
    const CustomThemeSupplier* theme_supplier) const {
  return false;
}

bool ThemeHelper::ShouldUseIncreasedContrastThemeSupplier(
    ui::NativeTheme* native_theme) const {
// TODO(crbug.com/1052397): Revisit once build flag switch of lacros-chrome is
// complete.
#if BUILDFLAG(USE_GTK) || BUILDFLAG(IS_CHROMEOS_LACROS)
  // On Linux the GTK system theme provides the high contrast colors,
  // so don't use the IncreasedContrastThemeSupplier.
  return false;
#else
  return native_theme && native_theme->UserHasContrastPreference();
#endif
}

SkColor ThemeHelper::GetDefaultColor(
    int id,
    bool incognito,
    const CustomThemeSupplier* theme_supplier) const {
  // For backward compat with older themes, some newer colors are generated from
  // older ones if they are missing.
  const auto get_frame_color = [this, incognito, theme_supplier](bool active) {
    return GetColor(active ? TP::COLOR_FRAME_ACTIVE : TP::COLOR_FRAME_INACTIVE,
                    incognito, theme_supplier);
  };
  switch (id) {
    case TP::COLOR_BOOKMARK_BAR_BACKGROUND:
    case TP::COLOR_TAB_BACKGROUND_ACTIVE_FRAME_ACTIVE:
    case TP::COLOR_TAB_BACKGROUND_ACTIVE_FRAME_INACTIVE:
      return GetColor(TP::COLOR_TOOLBAR, incognito, theme_supplier);
    case TP::COLOR_BOOKMARK_FAVICON: {
      SkColor color;
      return (theme_supplier &&
              theme_supplier->GetColor(TP::COLOR_TOOLBAR_BUTTON_ICON, &color))
                 ? color
                 : SK_ColorTRANSPARENT;
    }
    case TP::COLOR_FLYING_INDICATOR_BACKGROUND:
      return GetColor(TP::COLOR_TOOLBAR, incognito, theme_supplier);
    case TP::COLOR_FLYING_INDICATOR_FOREGROUND:
      return GetColor(TP::COLOR_TOOLBAR_BUTTON_ICON, incognito, theme_supplier);
    case TP::COLOR_FRAME_CAPTION_ACTIVE:
    case TP::COLOR_FRAME_CAPTION_INACTIVE:
      return color_utils::GetColorWithMaxContrast(GetColor(
          id == TP::COLOR_FRAME_CAPTION_ACTIVE ? TP::COLOR_FRAME_ACTIVE
                                               : TP::COLOR_FRAME_INACTIVE,
          incognito, theme_supplier));
    case TP::COLOR_BOOKMARK_TEXT:
    case TP::COLOR_TAB_FOREGROUND_ACTIVE_FRAME_ACTIVE:
    case TP::COLOR_TAB_FOREGROUND_ACTIVE_FRAME_INACTIVE:
      return GetColor(TP::COLOR_TOOLBAR_TEXT, incognito, theme_supplier);
    case TP::COLOR_TAB_STROKE_FRAME_ACTIVE:
      return GetColor(TP::COLOR_TOOLBAR_TOP_SEPARATOR_FRAME_ACTIVE, incognito,
                      theme_supplier);
    case TP::COLOR_TAB_STROKE_FRAME_INACTIVE:
      return GetColor(TP::COLOR_TOOLBAR_TOP_SEPARATOR_FRAME_INACTIVE, incognito,
                      theme_supplier);
    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_ACTIVE:
      return color_utils::HSLShift(get_frame_color(/*active=*/true),
                                   GetTint(ThemeProperties::TINT_BACKGROUND_TAB,
                                           incognito, theme_supplier));
    case TP::COLOR_TAB_BACKGROUND_INACTIVE_FRAME_INACTIVE:
      return color_utils::HSLShift(get_frame_color(/*active=*/false),
                                   GetTint(ThemeProperties::TINT_BACKGROUND_TAB,
                                           incognito, theme_supplier));
    case TP::COLOR_TOOLBAR_BUTTON_ICON:
    case TP::COLOR_TOOLBAR_BUTTON_ICON_HOVERED:
    case TP::COLOR_TOOLBAR_BUTTON_ICON_PRESSED:
      return color_utils::HSLShift(
          gfx::kGoogleGrey700,
          GetTint(TP::TINT_BUTTONS, incognito, theme_supplier));
    case TP::COLOR_TOOLBAR_BUTTON_ICON_INACTIVE:
      // The active color is overridden in GtkUi.
      return SkColorSetA(
          GetColor(TP::COLOR_TOOLBAR_BUTTON_ICON, incognito, theme_supplier),
          gfx::kGoogleGreyAlpha500);
    case TP::COLOR_LOCATION_BAR_BORDER:
      return SkColorSetA(SK_ColorBLACK, 0x4D);
    case TP::COLOR_LOCATION_BAR_BORDER_OPAQUE:
      return color_utils::GetResultingPaintColor(
          GetColor(TP::COLOR_LOCATION_BAR_BORDER, incognito, theme_supplier),
          GetColor(TP::COLOR_TOOLBAR, incognito, theme_supplier));
    case TP::COLOR_TOOLBAR_TOP_SEPARATOR_FRAME_ACTIVE:
    case TP::COLOR_TOOLBAR_TOP_SEPARATOR_FRAME_INACTIVE: {
      const SkColor toolbar_color =
          GetColor(TP::COLOR_TOOLBAR, incognito, theme_supplier);
      const SkColor frame_color = get_frame_color(
          /*active=*/id == TP::COLOR_TOOLBAR_TOP_SEPARATOR_FRAME_ACTIVE);
      const SeparatorColorKey key(toolbar_color, frame_color);
      auto i = GetSeparatorColorCache().find(key);
      if (i != GetSeparatorColorCache().end())
        return i->second;
      const SkColor separator_color =
          GetToolbarTopSeparatorColor(toolbar_color, frame_color);
      GetSeparatorColorCache()[key] = separator_color;
      return separator_color;
    }
    case TP::COLOR_BOOKMARK_SEPARATOR:
    case TP::COLOR_TOOLBAR_VERTICAL_SEPARATOR:
      return SkColorSetA(
          GetColor(TP::COLOR_TOOLBAR_BUTTON_ICON, incognito, theme_supplier),
          0x4D);
    case TP::COLOR_TOOLBAR_BUTTON_TEXT:
      // TODO(crbug.com/967317): Update to match mocks, i.e. return
      // gfx::kGoogleGrey900, if needed.
      [[fallthrough]];
    case TP::COLOR_TOOLBAR_INK_DROP:
      return color_utils::GetColorWithMaxContrast(
          GetColor(TP::COLOR_TOOLBAR, incognito, theme_supplier));
    case TP::COLOR_TOOLBAR_BUTTON_BORDER:
      return SkColorSetA(
          GetColor(TP::COLOR_TOOLBAR_INK_DROP, incognito, theme_supplier),
          0x20);
    case TP::COLOR_TOOLBAR_CONTENT_AREA_SEPARATOR:
      return color_utils::AlphaBlend(
          GetColor(TP::COLOR_TOOLBAR_BUTTON_ICON, incognito, theme_supplier),
          GetColor(TP::COLOR_TOOLBAR, incognito, theme_supplier),
          SkAlpha{0x3A});
    case TP::COLOR_NTP_SECTION_BORDER:
      return SkColorSetA(
          GetColor(TP::COLOR_NTP_HEADER, incognito, theme_supplier), 0x50);
    case TP::COLOR_NTP_TEXT_LIGHT:
      return IncreaseLightness(
          GetColor(TP::COLOR_NTP_TEXT, incognito, theme_supplier), 0.40);
    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_ACTIVE:
    case TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_INACTIVE:
      return GetColor(id == TP::COLOR_WINDOW_CONTROL_BUTTON_BACKGROUND_ACTIVE
                          ? TP::COLOR_FRAME_ACTIVE
                          : TP::COLOR_FRAME_INACTIVE,
                      incognito, theme_supplier);
  }

  return TP::GetDefaultColor(id, incognito, UseDarkModeColors(theme_supplier));
}

// static
bool ThemeHelper::UseDarkModeColors(const CustomThemeSupplier* theme_supplier) {
  // Dark mode is disabled for custom themes so they apply atop a predictable
  // state.
  if (IsCustomTheme(theme_supplier))
    return false;

  ui::NativeTheme const* native_theme =
      ui::NativeTheme::GetInstanceForNativeUi();
#if BUILDFLAG(IS_LINUX)
  if (const auto* linux_ui = views::LinuxUI::instance()) {
    // We rely on the fact that the system theme is in use iff `theme_supplier`
    // is non-null, but this is cheating. In the future this might not hold
    // after we fully migrate to the color provider and remove SystemThemeLinux.
    native_theme = linux_ui->GetNativeTheme(
        theme_supplier &&
        theme_supplier->get_theme_type() ==
            ui::ColorProviderManager::ThemeInitializerSupplier::ThemeType::
                kNativeX11);
  }
#endif
  return native_theme->ShouldUseDarkColors();
}

gfx::Image ThemeHelper::GetImageNamed(
    int id,
    bool incognito,
    const CustomThemeSupplier* theme_supplier) const {
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
  int adjusted_id = id;
  if (incognito) {
    if (id == IDR_THEME_FRAME)
      adjusted_id = IDR_THEME_FRAME_INCOGNITO;
    else if (id == IDR_THEME_FRAME_INACTIVE)
      adjusted_id = IDR_THEME_FRAME_INCOGNITO_INACTIVE;
  }

  gfx::Image image;
  if (theme_supplier)
    image = theme_supplier->GetImageNamed(adjusted_id);

  if (image.IsEmpty()) {
    image = ui::ResourceBundle::GetSharedInstance().GetNativeImageNamed(
        adjusted_id);
  }

  return image;
}
